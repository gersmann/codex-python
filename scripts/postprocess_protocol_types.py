#!/usr/bin/env python3
from __future__ import annotations

import re
from pathlib import Path


def main() -> int:
    p = Path("codex/protocol/types.py")
    s = p.read_text()

    # Fix recursive JsonValue forward refs to satisfy ruff F821
    # Quote bare JsonValue inside RootModel[...] first
    s = re.sub(r"RootModel\[([^\]]*?)JsonValue([^\]]*?)\]", r"RootModel[\1'JsonValue'\2]", s)
    # Then fix container occurrences
    s = re.sub(r"list\[JsonValue\]", "list['JsonValue']", s)
    s = re.sub(r"dict\[str, JsonValue\]", "dict[str, 'JsonValue']", s)
    # Normalize accidental double quotes if any
    s = s.replace("''JsonValue''", "'JsonValue'")

    # Add noqa for forward refs in union aliases so ruff F821 doesn't fire
    import re as _re

    # For RootModel union wrappers, drop the type parameter to avoid forward-ref NameError at class creation
    s = _re.sub(
        r"class\s+(EventMsg|ClientRequest|ServerRequest|ServerNotification|InputItem)\s*\(\s*RootModel\[[^\]]+\]\s*\):",
        lambda m: f"class {m.group(1)}(RootModel):",
        s,
    )
    s = _re.sub(r"(\s+root:\s*\([^\)]+\))", r"\1  # noqa: F821", s)
    # If previous runs introduced quotes around variant names, strip them inside union lines
    s = _re.sub(
        r"'((?:EventMsg|ClientRequest|ServerRequest|ServerNotification|InputItem)[A-Za-z0-9_]+)'",
        r"\1",
        s,
    )

    # Add a file-level ruff directive to ignore F821 in the generated file
    if "# ruff: noqa: F821" not in s.splitlines()[:5]:
        lines = s.splitlines()
        # insert after the header comment block (first non-empty line)
        for idx, line in enumerate(lines[:10]):
            if line.startswith("# generated by"):
                insert_at = idx + 1
                break
        else:
            insert_at = 1
        lines.insert(insert_at, "# ruff: noqa: F821")
        s = "\n".join(lines) + ("\n" if not s.endswith("\n") else "")

    # Convert optional fields that were marked required via Field(...)
    # Examples to fix:
    #   foo: str | None = Field(..., description='x')  -> Field(None, ...)
    #   foo: Optional[int] = Field(...)               -> Field(None)
    def _fix_optional_field_required(text: str) -> str:
        # With kwargs, union syntax
        text = re.sub(
            r"^(\s+[A-Za-z_][A-Za-z0-9_]*\s*:\s*[^\n=]*\|\s*None\s*=\s*)Field\(\s*\.\.\.(\s*,[^)]*)\)",
            r"\1Field(None\2)",
            text,
            flags=re.M,
        )
        # Without kwargs, union syntax
        text = re.sub(
            r"^(\s+[A-Za-z_][A-Za-z0-9_]*\s*:\s*[^\n=]*\|\s*None\s*=\s*)Field\(\s*\.\.\.\s*\)",
            r"\1Field(None)",
            text,
            flags=re.M,
        )
        # With kwargs, Optional[...] syntax
        text = re.sub(
            r"^(\s+[A-Za-z_][A-Za-z0-9_]*\s*:\s*Optional\[[^\]]+\]\s*=\s*)Field\(\s*\.\.\.(\s*,[^)]*)\)",
            r"\1Field(None\2)",
            text,
            flags=re.M,
        )
        # Without kwargs, Optional[...] syntax
        text = re.sub(
            r"^(\s+[A-Za-z_][A-Za-z0-9_]*\s*:\s*Optional\[[^\]]+\]\s*=\s*)Field\(\s*\.\.\.\s*\)",
            r"\1Field(None)",
            text,
            flags=re.M,
        )
        return text

    s = _fix_optional_field_required(s)

    # Append model_rebuild() calls for union RootModel wrappers to resolve forward refs
    wrappers = [
        "EventMsg",
        "ClientRequest",
        "ServerRequest",
        "ServerNotification",
        "InputItem",
    ]
    trailer = []
    for name in wrappers:
        if re.search(rf"^class\s+{name}\(\s*RootModel\s*\):", s, flags=re.M):
            trailer.append(f"{name}.model_rebuild()")
    if trailer:
        s = s.rstrip() + "\n\n" + "\n".join(trailer) + "\n"

    p.write_text(s)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
