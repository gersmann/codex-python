#!/usr/bin/env python3
from __future__ import annotations

import re
from pathlib import Path


def main() -> int:
    p = Path("codex/protocol/types.py")
    s = p.read_text()

    # Fix recursive JsonValue forward refs to satisfy ruff F821
    # Quote bare JsonValue inside RootModel[...] first
    s = re.sub(r"RootModel\[([^\]]*?)JsonValue([^\]]*?)\]", r"RootModel[\1'JsonValue'\2]", s)
    # Then fix container occurrences
    s = re.sub(r"list\[JsonValue\]", "list['JsonValue']", s)
    s = re.sub(r"dict\[str, JsonValue\]", "dict[str, 'JsonValue']", s)
    # Normalize accidental double quotes if any
    s = s.replace("''JsonValue''", "'JsonValue'")

    # Add noqa for forward refs in union aliases so ruff F821 doesn't fire
    import re as _re

    # For RootModel union wrappers, drop the type parameter to avoid forward-ref NameError at class creation
    s = _re.sub(
        r"class\s+(EventMsg|ClientRequest|ServerRequest|ServerNotification|InputItem)\s*\(\s*RootModel\[[^\]]+\]\s*\):",
        lambda m: f"class {m.group(1)}(RootModel):",
        s,
    )
    s = _re.sub(r"(\s+root:\s*\([^\)]+\))", r"\1  # noqa: F821", s)
    # If previous runs introduced quotes around variant names, strip them inside union lines
    s = _re.sub(
        r"'((?:EventMsg|ClientRequest|ServerRequest|ServerNotification|InputItem)[A-Za-z0-9_]+)'",
        r"\1",
        s,
    )

    # Add a file-level ruff directive to ignore F821 in the generated file
    if "# ruff: noqa: F821" not in s.splitlines()[:5]:
        lines = s.splitlines()
        # insert after the header comment block (first non-empty line)
        for idx, line in enumerate(lines[:10]):
            if line.startswith("# generated by"):
                insert_at = idx + 1
                break
        else:
            insert_at = 1
        lines.insert(insert_at, "# ruff: noqa: F821")
        s = "\n".join(lines) + ("\n" if not s.endswith("\n") else "")

    # Convert optional fields that were marked required via Field(...)
    # Examples to fix:
    #   foo: str | None = Field(..., description='x')  -> Field(None, ...)
    #   foo: Optional[int] = Field(...)               -> Field(None)
    def _fix_optional_field_required(text: str) -> str:
        # With kwargs, union syntax
        text = re.sub(
            r"^(\s+[A-Za-z_][A-Za-z0-9_]*\s*:\s*[^\n=]*\|\s*None\s*=\s*)Field\(\s*\.\.\.(\s*,[^)]*)\)",
            r"\1Field(None\2)",
            text,
            flags=re.M,
        )
        # Without kwargs, union syntax
        text = re.sub(
            r"^(\s+[A-Za-z_][A-Za-z0-9_]*\s*:\s*[^\n=]*\|\s*None\s*=\s*)Field\(\s*\.\.\.\s*\)",
            r"\1Field(None)",
            text,
            flags=re.M,
        )
        # With kwargs, Optional[...] syntax
        text = re.sub(
            r"^(\s+[A-Za-z_][A-Za-z0-9_]*\s*:\s*Optional\[[^\]]+\]\s*=\s*)Field\(\s*\.\.\.(\s*,[^)]*)\)",
            r"\1Field(None\2)",
            text,
            flags=re.M,
        )
        # Without kwargs, Optional[...] syntax
        text = re.sub(
            r"^(\s+[A-Za-z_][A-Za-z0-9_]*\s*:\s*Optional\[[^\]]+\]\s*=\s*)Field\(\s*\.\.\.\s*\)",
            r"\1Field(None)",
            text,
            flags=re.M,
        )
        return text

    s = _fix_optional_field_required(s)

    # Append model_rebuild() calls for union RootModel wrappers to resolve forward refs
    wrappers = [
        "EventMsg",
        "ClientRequest",
        "ServerRequest",
        "ServerNotification",
        "InputItem",
    ]
    trailer = []
    for name in wrappers:
        if re.search(rf"^class\s+{name}\(\s*RootModel\s*\):", s, flags=re.M):
            trailer.append(f"{name}.model_rebuild()")
    if trailer:
        s = s.rstrip() + "\n\n" + "\n".join(trailer) + "\n"

    # Deduplicate any duplicate .model_rebuild() lines and optionally print a summary
    import re as _re2

    matches = list(_re2.finditer(r"^(\w+)\.model_rebuild\(\)\s*$", s, flags=_re2.M))
    seen = set()
    deduped_lines = []
    removed = 0
    if matches:
        lines = s.splitlines()
        for _i, ln in enumerate(lines):
            m = _re2.match(r"^(\w+)\.model_rebuild\(\)\s*$", ln)
            if not m:
                deduped_lines.append(ln)
                continue
            name = m.group(1)
            if name in seen:
                removed += 1
                continue
            seen.add(name)
            deduped_lines.append(ln)
        s = "\n".join(deduped_lines) + ("\n" if s.endswith("\n") else "")

    p.write_text(s)
    if removed:
        print(f"Types postprocess: removed {removed} duplicate model_rebuild() lines")
    else:
        print("Types postprocess: no duplicate model_rebuild() lines found")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
